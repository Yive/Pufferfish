From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kevin Raneri <kevin.raneri@gmail.com>
Date: Fri, 1 Nov 2024 22:20:06 -0500
Subject: [PATCH] Optimize mob spawning

This patch aims to reduce the main-thread impact of mob spawning by
offloading as much work as possible to other threads. It is possible for
inconsistencies to come up, but when they happen they never interfere
with the server's operation (they don't produce errors), and side
effects are limited to more or less mobs being spawned in any particular
tick.

It is possible to disable this optimization if it is not required or if
it interferes with any plugins. On servers with thousands of entities,
this can result in performance gains of up to 15%, which is significant
and, in my opinion, worth the low risk of minor mob-spawning-related
inconsistencies.

diff --git a/net/minecraft/server/MinecraftServer.java b/net/minecraft/server/MinecraftServer.java
index 107aa863bd4448628b013d0ccd49b6a956aeffef..f70761d0547c713f2841e980725d244963dc8da7 100644
--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -303,6 +303,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public boolean isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
     private final Set<String> pluginsBlockingSleep = new java.util.HashSet<>(); // Paper - API to allow/disallow tick sleeping
     public static final long SERVER_INIT = System.nanoTime(); // Paper - Lag compensation
+    public gg.pufferfish.pufferfish.util.AsyncExecutor mobSpawnExecutor = new gg.pufferfish.pufferfish.util.AsyncExecutor("MobSpawning"); // Pufferfish - optimize mob spawning
 
     public static <S extends MinecraftServer> S spin(Function<Thread, S> threadFunction) {
         ca.spottedleaf.dataconverter.minecraft.datatypes.MCTypeRegistry.init(); // Paper - rewrite data converter system
diff --git a/net/minecraft/server/dedicated/DedicatedServer.java b/net/minecraft/server/dedicated/DedicatedServer.java
index 26356aa8bc18cf3a146639482dcee0c79408b314..2bcdaf75496aba7ad786cd3ebcfbefcc7ca922f2 100644
--- a/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/net/minecraft/server/dedicated/DedicatedServer.java
@@ -352,6 +352,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
                 LOGGER.info("JMX monitoring enabled");
             }
 
+            if (gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning) mobSpawnExecutor.start(); // Pufferfish
             return true;
         }
     }
diff --git a/net/minecraft/server/level/ServerChunkCache.java b/net/minecraft/server/level/ServerChunkCache.java
index 6540b2d6a1062d883811ce240c49d30d1925b291..71f2d1ee2fa5e266d81f27bb818d8fc288007abc 100644
--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -181,6 +181,8 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     }
     // Paper end - chunk tick iteration optimisations
 
+    public boolean firstRunSpawnCounts = true; // Pufferfish
+    public final java.util.concurrent.atomic.AtomicBoolean _pufferfish_spawnCountsReady = new java.util.concurrent.atomic.AtomicBoolean(false); // Pufferfish - optimize countmobs
 
     public ServerChunkCache(
         ServerLevel level,
@@ -528,6 +530,43 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
             this.broadcastChangedChunks(profilerFiller);
             profilerFiller.pop();
+
+            // Pufferfish start - optimize mob spawning
+            if (gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning) {
+                for (ServerPlayer player : this.level.players) {
+                    // Paper start - per player mob spawning backoff
+                    for (int ii = 0; ii < ServerPlayer.MOBCATEGORY_TOTAL_ENUMS; ii++) {
+                        player.mobCounts[ii] = 0;
+
+                        int newBackoff = player.mobBackoffCounts[ii] - 1; // TODO make configurable bleed // TODO use nonlinear algorithm?
+                        if (newBackoff < 0) {
+                            newBackoff = 0;
+                        }
+                        player.mobBackoffCounts[ii] = newBackoff;
+                    }
+                    // Paper end - per player mob spawning backoff
+                }
+                if (firstRunSpawnCounts) {
+                    firstRunSpawnCounts = false;
+                    _pufferfish_spawnCountsReady.set(true);
+                }
+                if (_pufferfish_spawnCountsReady.getAndSet(false)) {
+                    net.minecraft.server.MinecraftServer.getServer().mobSpawnExecutor.submit(() -> {
+                        int mapped = distanceManager.getNaturalSpawnChunkCount();
+                        ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet.Iterator<Entity> objectiterator =
+                                level.entityTickList.entities.iterator(ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS);
+                        try {
+                            gg.pufferfish.pufferfish.util.IterableWrapper<Entity> wrappedIterator =
+                                    new gg.pufferfish.pufferfish.util.IterableWrapper<>(objectiterator);
+                            lastSpawnState = NaturalSpawner.createState(mapped, wrappedIterator, this::getFullChunk, null, true);
+                        } finally {
+                            objectiterator.finishedIterating();
+                        }
+                        _pufferfish_spawnCountsReady.set(true);
+                    });
+                }
+            }
+            // Pufferfish end
         }
     }
 
@@ -574,6 +613,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         // Paper start - Optional per player mob spawns
         NaturalSpawner.SpawnState spawnState;
         if ((this.spawnFriendlies || this.spawnEnemies) && this.level.paperConfig().entities.spawning.perPlayerMobSpawns) { // don't count mobs when animals and monsters are disabled
+            if (!gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning) { // Pufferfish - moved down when async processing
             // re-set mob counts
             for (ServerPlayer player : this.level.players) {
                 // Paper start - per player mob spawning backoff
@@ -588,12 +628,16 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                 }
                 // Paper end - per player mob spawning backoff
             }
-            spawnState = NaturalSpawner.createState(naturalSpawnChunkCount, this.level.getAllEntities(), this::getFullChunk, null, true);
+            lastSpawnState = NaturalSpawner.createState(naturalSpawnChunkCount, this.level.getAllEntities(), this::getFullChunk, null, true); // Pufferfish - async mob spawning
+            } // Pufferfish - (endif) moved down when async processing
         } else {
-            spawnState = NaturalSpawner.createState(naturalSpawnChunkCount, this.level.getAllEntities(), this::getFullChunk, !this.level.paperConfig().entities.spawning.perPlayerMobSpawns ? new LocalMobCapCalculator(this.chunkMap) : null, false);
+            // Pufferfish start - async mob spawning
+            lastSpawnState = NaturalSpawner.createState(naturalSpawnChunkCount, this.level.getAllEntities(), this::getFullChunk, !this.level.paperConfig().entities.spawning.perPlayerMobSpawns ? new LocalMobCapCalculator(this.chunkMap) : null, false);
+            _pufferfish_spawnCountsReady.set(true);
+            // Pufferfish end
         }
         // Paper end - Optional per player mob spawns
-        this.lastSpawnState = spawnState;
+        // this.lastSpawnState = spawnState; // Pufferfish - this is managed asynchronously
         profiler.popPush("spawnAndTick");
         boolean _boolean = this.level.getGameRules().getBoolean(GameRules.RULE_DOMOBSPAWNING) && !this.level.players().isEmpty(); // CraftBukkit
         int _int = this.level.getGameRules().getInt(GameRules.RULE_RANDOMTICKING);
@@ -608,7 +652,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
             }
             // Paper end - PlayerNaturallySpawnCreaturesEvent
             boolean flag = this.level.ticksPerSpawnCategory.getLong(org.bukkit.entity.SpawnCategory.ANIMAL) != 0L && this.level.getLevelData().getGameTime() % this.level.ticksPerSpawnCategory.getLong(org.bukkit.entity.SpawnCategory.ANIMAL) == 0L; // CraftBukkit
-            filteredSpawningCategories = NaturalSpawner.getFilteredSpawningCategories(spawnState, this.spawnFriendlies, this.spawnEnemies, flag, this.level); // CraftBukkit
+            filteredSpawningCategories = NaturalSpawner.getFilteredSpawningCategories(lastSpawnState, this.spawnFriendlies, this.spawnEnemies, flag, this.level); // CraftBukkit // Pufferfish
         } else {
             filteredSpawningCategories = List.of();
         }
@@ -616,8 +660,8 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         for (LevelChunk levelChunk : chunks) {
             ChunkPos pos = levelChunk.getPos();
             levelChunk.incrementInhabitedTime(timeInhabited);
-            if (!filteredSpawningCategories.isEmpty() && this.level.getWorldBorder().isWithinBounds(pos) && this.chunkMap.anyPlayerCloseEnoughForSpawning(pos, true)) { // Spigot
-                NaturalSpawner.spawnForChunk(this.level, levelChunk, spawnState, filteredSpawningCategories);
+            if (!filteredSpawningCategories.isEmpty() && this.level.getWorldBorder().isWithinBounds(pos) && (!gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning || _pufferfish_spawnCountsReady.get()) && this.chunkMap.anyPlayerCloseEnoughForSpawning(pos, true)) { // Spigot // Pufferfish
+                NaturalSpawner.spawnForChunk(this.level, levelChunk, lastSpawnState, filteredSpawningCategories); // Pufferfish
             }
 
             if (true) { // Paper - rewrite chunk system
diff --git a/net/minecraft/world/level/entity/EntityTickList.java b/net/minecraft/world/level/entity/EntityTickList.java
index 423779a2b690f387a4f0bd07b97b50e0baefda76..0f83a9335a7b65b2c1f98704cef5ee321156cc0c 100644
--- a/net/minecraft/world/level/entity/EntityTickList.java
+++ b/net/minecraft/world/level/entity/EntityTickList.java
@@ -9,7 +9,7 @@ import javax.annotation.Nullable;
 import net.minecraft.world.entity.Entity;
 
 public class EntityTickList {
-    private final ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<net.minecraft.world.entity.Entity> entities = new ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<>(); // Paper - rewrite chunk system
+    public final ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<net.minecraft.world.entity.Entity> entities = new ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<>(); // Paper - rewrite chunk system // Pufferfish
 
     private void ensureActiveIsNotIterated() {
         // Paper - rewrite chunk system
